/// Generated by the Protocol Buffers 3.4.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "Protocol.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Pb { }

public extension Pb {
    public struct ProtocolRoot {
        public static let `default` = ProtocolRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class Inventory : GeneratedMessage {
        public typealias BuilderType = Pb.Inventory.Builder

        public static func == (lhs: Pb.Inventory, rhs: Pb.Inventory) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hash == rhs.hash)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var hash:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !hash.isEmpty {
                for oneValuehash in hash {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuehash)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeHash:Int32 = 0
            for oneValuehash in hash {
                dataSizeHash += oneValuehash.computeStringSizeNoTag()
            }
            serialize_size += dataSizeHash
            serialize_size += 1 * Int32(hash.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Pb.Inventory.Builder {
            return Pb.Inventory.classBuilder() as! Pb.Inventory.Builder
        }
        public func getBuilder() -> Pb.Inventory.Builder {
            return classBuilder() as! Pb.Inventory.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Inventory.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Inventory.Builder()
        }
        public func toBuilder() throws -> Pb.Inventory.Builder {
            return try Pb.Inventory.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pb.Inventory) throws -> Pb.Inventory.Builder {
            return try Pb.Inventory.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !hash.isEmpty {
                var jsonArrayHash:Array<String> = []
                for oneValueHash in hash {
                    jsonArrayHash.append(oneValueHash)
                }
                jsonMap["hash"] = jsonArrayHash
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pb.Inventory {
            return try Pb.Inventory.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pb.Inventory {
            return try Pb.Inventory.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var hashElementIndex:Int = 0
            for oneValueHash in hash  {
                output += "\(indent) hash[\(hashElementIndex)]: \(oneValueHash)\n"
                hashElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueHash in hash {
                    hashCode = (hashCode &* 31) &+ oneValueHash.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pb.Inventory"
        }
        override public func className() -> String {
            return "Pb.Inventory"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Pb.Inventory = Pb.Inventory()
            public func getMessage() -> Pb.Inventory {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hash:Array<String> {
                get {
                    return builderResult.hash
                }
                set (array) {
                    builderResult.hash = array
                }
            }
            @discardableResult
            public func setHash(_ value:Array<String>) -> Pb.Inventory.Builder {
                self.hash = value
                return self
            }
            @discardableResult
            public func clearHash() -> Pb.Inventory.Builder {
                builderResult.hash.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Pb.Inventory.Builder {
                builderResult = Pb.Inventory()
                return self
            }
            override public func clone() throws -> Pb.Inventory.Builder {
                return try Pb.Inventory.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Pb.Inventory {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Pb.Inventory {
                let returnMe:Pb.Inventory = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Pb.Inventory) throws -> Pb.Inventory.Builder {
                if other == Pb.Inventory() {
                    return self
                }
                if !other.hash.isEmpty {
                    builderResult.hash += other.hash
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pb.Inventory.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        hash += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pb.Inventory.Builder {
                let resultDecodedBuilder = Pb.Inventory.Builder()
                if let jsonValueHash = jsonMap["hash"] as? Array<String> {
                    var jsonArrayHash:Array<String> = []
                    for oneValueHash in jsonValueHash {
                        jsonArrayHash.append(oneValueHash)
                    }
                    resultDecodedBuilder.hash = jsonArrayHash
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Pb.Inventory.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Pb.Inventory.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class InventoryItemRequest : GeneratedMessage {
        public typealias BuilderType = Pb.InventoryItemRequest.Builder

        public static func == (lhs: Pb.InventoryItemRequest, rhs: Pb.InventoryItemRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hash == rhs.hash)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var hash:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !hash.isEmpty {
                for oneValuehash in hash {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuehash)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeHash:Int32 = 0
            for oneValuehash in hash {
                dataSizeHash += oneValuehash.computeStringSizeNoTag()
            }
            serialize_size += dataSizeHash
            serialize_size += 1 * Int32(hash.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Pb.InventoryItemRequest.Builder {
            return Pb.InventoryItemRequest.classBuilder() as! Pb.InventoryItemRequest.Builder
        }
        public func getBuilder() -> Pb.InventoryItemRequest.Builder {
            return classBuilder() as! Pb.InventoryItemRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.InventoryItemRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.InventoryItemRequest.Builder()
        }
        public func toBuilder() throws -> Pb.InventoryItemRequest.Builder {
            return try Pb.InventoryItemRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pb.InventoryItemRequest) throws -> Pb.InventoryItemRequest.Builder {
            return try Pb.InventoryItemRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !hash.isEmpty {
                var jsonArrayHash:Array<String> = []
                for oneValueHash in hash {
                    jsonArrayHash.append(oneValueHash)
                }
                jsonMap["hash"] = jsonArrayHash
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pb.InventoryItemRequest {
            return try Pb.InventoryItemRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pb.InventoryItemRequest {
            return try Pb.InventoryItemRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var hashElementIndex:Int = 0
            for oneValueHash in hash  {
                output += "\(indent) hash[\(hashElementIndex)]: \(oneValueHash)\n"
                hashElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueHash in hash {
                    hashCode = (hashCode &* 31) &+ oneValueHash.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pb.InventoryItemRequest"
        }
        override public func className() -> String {
            return "Pb.InventoryItemRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Pb.InventoryItemRequest = Pb.InventoryItemRequest()
            public func getMessage() -> Pb.InventoryItemRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hash:Array<String> {
                get {
                    return builderResult.hash
                }
                set (array) {
                    builderResult.hash = array
                }
            }
            @discardableResult
            public func setHash(_ value:Array<String>) -> Pb.InventoryItemRequest.Builder {
                self.hash = value
                return self
            }
            @discardableResult
            public func clearHash() -> Pb.InventoryItemRequest.Builder {
                builderResult.hash.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Pb.InventoryItemRequest.Builder {
                builderResult = Pb.InventoryItemRequest()
                return self
            }
            override public func clone() throws -> Pb.InventoryItemRequest.Builder {
                return try Pb.InventoryItemRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Pb.InventoryItemRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Pb.InventoryItemRequest {
                let returnMe:Pb.InventoryItemRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Pb.InventoryItemRequest) throws -> Pb.InventoryItemRequest.Builder {
                if other == Pb.InventoryItemRequest() {
                    return self
                }
                if !other.hash.isEmpty {
                    builderResult.hash += other.hash
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pb.InventoryItemRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        hash += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pb.InventoryItemRequest.Builder {
                let resultDecodedBuilder = Pb.InventoryItemRequest.Builder()
                if let jsonValueHash = jsonMap["hash"] as? Array<String> {
                    var jsonArrayHash:Array<String> = []
                    for oneValueHash in jsonValueHash {
                        jsonArrayHash.append(oneValueHash)
                    }
                    resultDecodedBuilder.hash = jsonArrayHash
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Pb.InventoryItemRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Pb.InventoryItemRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class InventoryItemResponse : GeneratedMessage {
        public typealias BuilderType = Pb.InventoryItemResponse.Builder

        public static func == (lhs: Pb.InventoryItemResponse, rhs: Pb.InventoryItemResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var from:String! = nil
        public fileprivate(set) var hasFrom:Bool = false

        public fileprivate(set) var data:String! = nil
        public fileprivate(set) var hasData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFrom {
                try codedOutputStream.writeString(fieldNumber: 1, value:from)
            }
            if hasData {
                try codedOutputStream.writeString(fieldNumber: 2, value:data)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFrom {
                serialize_size += from.computeStringSize(fieldNumber: 1)
            }
            if hasData {
                serialize_size += data.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Pb.InventoryItemResponse.Builder {
            return Pb.InventoryItemResponse.classBuilder() as! Pb.InventoryItemResponse.Builder
        }
        public func getBuilder() -> Pb.InventoryItemResponse.Builder {
            return classBuilder() as! Pb.InventoryItemResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.InventoryItemResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.InventoryItemResponse.Builder()
        }
        public func toBuilder() throws -> Pb.InventoryItemResponse.Builder {
            return try Pb.InventoryItemResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pb.InventoryItemResponse) throws -> Pb.InventoryItemResponse.Builder {
            return try Pb.InventoryItemResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFrom {
                jsonMap["from"] = from
            }
            if hasData {
                jsonMap["data"] = data
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pb.InventoryItemResponse {
            return try Pb.InventoryItemResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pb.InventoryItemResponse {
            return try Pb.InventoryItemResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFrom {
                output += "\(indent) from: \(from) \n"
            }
            if hasData {
                output += "\(indent) data: \(data) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFrom {
                    hashCode = (hashCode &* 31) &+ from.hashValue
                }
                if hasData {
                    hashCode = (hashCode &* 31) &+ data.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pb.InventoryItemResponse"
        }
        override public func className() -> String {
            return "Pb.InventoryItemResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Pb.InventoryItemResponse = Pb.InventoryItemResponse()
            public func getMessage() -> Pb.InventoryItemResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var from:String {
                get {
                    return builderResult.from
                }
                set (value) {
                    builderResult.hasFrom = true
                    builderResult.from = value
                }
            }
            public var hasFrom:Bool {
                get {
                    return builderResult.hasFrom
                }
            }
            @discardableResult
            public func setFrom(_ value:String) -> Pb.InventoryItemResponse.Builder {
                self.from = value
                return self
            }
            @discardableResult
            public func clearFrom() -> Pb.InventoryItemResponse.Builder{
                builderResult.hasFrom = false
                builderResult.from = nil
                return self
            }
            public var data:String {
                get {
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            @discardableResult
            public func setData(_ value:String) -> Pb.InventoryItemResponse.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func clearData() -> Pb.InventoryItemResponse.Builder{
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Pb.InventoryItemResponse.Builder {
                builderResult = Pb.InventoryItemResponse()
                return self
            }
            override public func clone() throws -> Pb.InventoryItemResponse.Builder {
                return try Pb.InventoryItemResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Pb.InventoryItemResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Pb.InventoryItemResponse {
                let returnMe:Pb.InventoryItemResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Pb.InventoryItemResponse) throws -> Pb.InventoryItemResponse.Builder {
                if other == Pb.InventoryItemResponse() {
                    return self
                }
                if other.hasFrom {
                    from = other.from
                }
                if other.hasData {
                    data = other.data
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pb.InventoryItemResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        from = try codedInputStream.readString()

                    case 18:
                        data = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pb.InventoryItemResponse.Builder {
                let resultDecodedBuilder = Pb.InventoryItemResponse.Builder()
                if let jsonValueFrom = jsonMap["from"] as? String {
                    resultDecodedBuilder.from = jsonValueFrom
                }
                if let jsonValueData = jsonMap["data"] as? String {
                    resultDecodedBuilder.data = jsonValueData
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Pb.InventoryItemResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Pb.InventoryItemResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Message : GeneratedMessage {
        public typealias BuilderType = Pb.Message.Builder

        public static func == (lhs: Pb.Message, rhs: Pb.Message) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = fieldCheck && (lhs.hasInventory == rhs.hasInventory) && (!lhs.hasInventory || lhs.inventory == rhs.inventory)
            fieldCheck = fieldCheck && (lhs.hasInventoryRequest == rhs.hasInventoryRequest) && (!lhs.hasInventoryRequest || lhs.inventoryRequest == rhs.inventoryRequest)
            fieldCheck = fieldCheck && (lhs.hasInventoryResponse == rhs.hasInventoryResponse) && (!lhs.hasInventoryResponse || lhs.inventoryResponse == rhs.inventoryResponse)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Msg {
            case OneOfMsgNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfMsgNotSet: return false
                default: return true
                }
            }
            case Inventory(Pb.Inventory)

            public static func getInventory(_ value:Msg) -> Pb.Inventory? {
                switch value {
                case .Inventory(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case InventoryRequest(Pb.InventoryItemRequest)

            public static func getInventoryRequest(_ value:Msg) -> Pb.InventoryItemRequest? {
                switch value {
                case .InventoryRequest(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case InventoryResponse(Pb.InventoryItemResponse)

            public static func getInventoryResponse(_ value:Msg) -> Pb.InventoryItemResponse? {
                switch value {
                case .InventoryResponse(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageMsg:Message.Msg =  Message.Msg.OneOfMsgNotSet
        public func getOneOfMsg() ->  Message.Msg {
            let copyObjectMsg = storageMsg
            return copyObjectMsg
        }
        public fileprivate(set) var version:Int64! = nil
        public fileprivate(set) var hasVersion:Bool = false

        public fileprivate(set) var inventory:Pb.Inventory!{
            get {
                return Message.Msg.getInventory(storageMsg)
            }
            set (newvalue) {
                storageMsg = Message.Msg.Inventory(newvalue)
            }
        }
        public fileprivate(set) var hasInventory:Bool {
            get {
                guard let _ = Message.Msg.getInventory(storageMsg) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var inventoryRequest:Pb.InventoryItemRequest!{
            get {
                return Message.Msg.getInventoryRequest(storageMsg)
            }
            set (newvalue) {
                storageMsg = Message.Msg.InventoryRequest(newvalue)
            }
        }
        public fileprivate(set) var hasInventoryRequest:Bool {
            get {
                guard let _ = Message.Msg.getInventoryRequest(storageMsg) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var inventoryResponse:Pb.InventoryItemResponse!{
            get {
                return Message.Msg.getInventoryResponse(storageMsg)
            }
            set (newvalue) {
                storageMsg = Message.Msg.InventoryResponse(newvalue)
            }
        }
        public fileprivate(set) var hasInventoryResponse:Bool {
            get {
                guard let _ = Message.Msg.getInventoryResponse(storageMsg) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasVersion {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:version)
            }
            if hasInventory {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:inventory)
            }
            if hasInventoryRequest {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:inventoryRequest)
            }
            if hasInventoryResponse {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:inventoryResponse)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasVersion {
                serialize_size += version.computeInt64Size(fieldNumber: 1)
            }
            if hasInventory {
                if let varSizeinventory = inventory?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeinventory
                }
            }
            if hasInventoryRequest {
                if let varSizeinventoryRequest = inventoryRequest?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeinventoryRequest
                }
            }
            if hasInventoryResponse {
                if let varSizeinventoryResponse = inventoryResponse?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeinventoryResponse
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Pb.Message.Builder {
            return Pb.Message.classBuilder() as! Pb.Message.Builder
        }
        public func getBuilder() -> Pb.Message.Builder {
            return classBuilder() as! Pb.Message.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Message.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Message.Builder()
        }
        public func toBuilder() throws -> Pb.Message.Builder {
            return try Pb.Message.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pb.Message) throws -> Pb.Message.Builder {
            return try Pb.Message.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasVersion {
                jsonMap["version"] = "\(version)"
            }
            if hasInventory {
                jsonMap["inventory"] = try inventory.encode()
            }
            if hasInventoryRequest {
                jsonMap["inventoryRequest"] = try inventoryRequest.encode()
            }
            if hasInventoryResponse {
                jsonMap["inventoryResponse"] = try inventoryResponse.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pb.Message {
            return try Pb.Message.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pb.Message {
            return try Pb.Message.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            if hasInventory {
                output += "\(indent) inventory {\n"
                if let outDescInventory = inventory {
                    output += try outDescInventory.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInventoryRequest {
                output += "\(indent) inventoryRequest {\n"
                if let outDescInventoryRequest = inventoryRequest {
                    output += try outDescInventoryRequest.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInventoryResponse {
                output += "\(indent) inventoryResponse {\n"
                if let outDescInventoryResponse = inventoryResponse {
                    output += try outDescInventoryResponse.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasInventory {
                    if let hashValueinventory = inventory?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinventory
                    }
                }
                if hasInventoryRequest {
                    if let hashValueinventoryRequest = inventoryRequest?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinventoryRequest
                    }
                }
                if hasInventoryResponse {
                    if let hashValueinventoryResponse = inventoryResponse?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinventoryResponse
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pb.Message"
        }
        override public func className() -> String {
            return "Pb.Message"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Pb.Message = Pb.Message()
            public func getMessage() -> Pb.Message {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var version:Int64 {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:Int64) -> Pb.Message.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Pb.Message.Builder{
                builderResult.hasVersion = false
                builderResult.version = nil
                return self
            }
            public var inventory:Pb.Inventory! {
                get {
                    if inventoryBuilder_ != nil {
                        builderResult.inventory = inventoryBuilder_.getMessage()
                    }
                    return builderResult.inventory
                }
                set (value) {
                    builderResult.hasInventory = true
                    builderResult.inventory = value
                }
            }
            public var hasInventory:Bool {
                get {
                    return builderResult.hasInventory
                }
            }
            fileprivate var inventoryBuilder_:Pb.Inventory.Builder! {
                didSet {
                    builderResult.hasInventory = true
                }
            }
            public func getInventoryBuilder() -> Pb.Inventory.Builder {
                if inventoryBuilder_ == nil {
                    inventoryBuilder_ = Pb.Inventory.Builder()
                    builderResult.inventory = inventoryBuilder_.getMessage()
                    if inventory != nil {
                        try! inventoryBuilder_.mergeFrom(other: inventory)
                    }
                }
                return inventoryBuilder_
            }
            @discardableResult
            public func setInventory(_ value:Pb.Inventory!) -> Pb.Message.Builder {
                self.inventory = value
                return self
            }
            @discardableResult
            public func mergeInventory(value:Pb.Inventory) throws -> Pb.Message.Builder {
                if builderResult.hasInventory {
                    builderResult.inventory = try Pb.Inventory.builderWithPrototype(prototype:builderResult.inventory).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.inventory = value
                }
                builderResult.hasInventory = true
                return self
            }
            @discardableResult
            public func clearInventory() -> Pb.Message.Builder {
                inventoryBuilder_ = nil
                builderResult.hasInventory = false
                builderResult.inventory = nil
                return self
            }
            public var inventoryRequest:Pb.InventoryItemRequest! {
                get {
                    if inventoryRequestBuilder_ != nil {
                        builderResult.inventoryRequest = inventoryRequestBuilder_.getMessage()
                    }
                    return builderResult.inventoryRequest
                }
                set (value) {
                    builderResult.hasInventoryRequest = true
                    builderResult.inventoryRequest = value
                }
            }
            public var hasInventoryRequest:Bool {
                get {
                    return builderResult.hasInventoryRequest
                }
            }
            fileprivate var inventoryRequestBuilder_:Pb.InventoryItemRequest.Builder! {
                didSet {
                    builderResult.hasInventoryRequest = true
                }
            }
            public func getInventoryRequestBuilder() -> Pb.InventoryItemRequest.Builder {
                if inventoryRequestBuilder_ == nil {
                    inventoryRequestBuilder_ = Pb.InventoryItemRequest.Builder()
                    builderResult.inventoryRequest = inventoryRequestBuilder_.getMessage()
                    if inventoryRequest != nil {
                        try! inventoryRequestBuilder_.mergeFrom(other: inventoryRequest)
                    }
                }
                return inventoryRequestBuilder_
            }
            @discardableResult
            public func setInventoryRequest(_ value:Pb.InventoryItemRequest!) -> Pb.Message.Builder {
                self.inventoryRequest = value
                return self
            }
            @discardableResult
            public func mergeInventoryRequest(value:Pb.InventoryItemRequest) throws -> Pb.Message.Builder {
                if builderResult.hasInventoryRequest {
                    builderResult.inventoryRequest = try Pb.InventoryItemRequest.builderWithPrototype(prototype:builderResult.inventoryRequest).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.inventoryRequest = value
                }
                builderResult.hasInventoryRequest = true
                return self
            }
            @discardableResult
            public func clearInventoryRequest() -> Pb.Message.Builder {
                inventoryRequestBuilder_ = nil
                builderResult.hasInventoryRequest = false
                builderResult.inventoryRequest = nil
                return self
            }
            public var inventoryResponse:Pb.InventoryItemResponse! {
                get {
                    if inventoryResponseBuilder_ != nil {
                        builderResult.inventoryResponse = inventoryResponseBuilder_.getMessage()
                    }
                    return builderResult.inventoryResponse
                }
                set (value) {
                    builderResult.hasInventoryResponse = true
                    builderResult.inventoryResponse = value
                }
            }
            public var hasInventoryResponse:Bool {
                get {
                    return builderResult.hasInventoryResponse
                }
            }
            fileprivate var inventoryResponseBuilder_:Pb.InventoryItemResponse.Builder! {
                didSet {
                    builderResult.hasInventoryResponse = true
                }
            }
            public func getInventoryResponseBuilder() -> Pb.InventoryItemResponse.Builder {
                if inventoryResponseBuilder_ == nil {
                    inventoryResponseBuilder_ = Pb.InventoryItemResponse.Builder()
                    builderResult.inventoryResponse = inventoryResponseBuilder_.getMessage()
                    if inventoryResponse != nil {
                        try! inventoryResponseBuilder_.mergeFrom(other: inventoryResponse)
                    }
                }
                return inventoryResponseBuilder_
            }
            @discardableResult
            public func setInventoryResponse(_ value:Pb.InventoryItemResponse!) -> Pb.Message.Builder {
                self.inventoryResponse = value
                return self
            }
            @discardableResult
            public func mergeInventoryResponse(value:Pb.InventoryItemResponse) throws -> Pb.Message.Builder {
                if builderResult.hasInventoryResponse {
                    builderResult.inventoryResponse = try Pb.InventoryItemResponse.builderWithPrototype(prototype:builderResult.inventoryResponse).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.inventoryResponse = value
                }
                builderResult.hasInventoryResponse = true
                return self
            }
            @discardableResult
            public func clearInventoryResponse() -> Pb.Message.Builder {
                inventoryResponseBuilder_ = nil
                builderResult.hasInventoryResponse = false
                builderResult.inventoryResponse = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Pb.Message.Builder {
                builderResult = Pb.Message()
                return self
            }
            override public func clone() throws -> Pb.Message.Builder {
                return try Pb.Message.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Pb.Message {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Pb.Message {
                let returnMe:Pb.Message = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Pb.Message) throws -> Pb.Message.Builder {
                if other == Pb.Message() {
                    return self
                }
                if other.hasVersion {
                    version = other.version
                }
                if (other.hasInventory) {
                    try mergeInventory(value: other.inventory)
                }
                if (other.hasInventoryRequest) {
                    try mergeInventoryRequest(value: other.inventoryRequest)
                }
                if (other.hasInventoryResponse) {
                    try mergeInventoryResponse(value: other.inventoryResponse)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pb.Message.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Message.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        version = try codedInputStream.readInt64()

                    case 18:
                        let subBuilder:Pb.Inventory.Builder = Pb.Inventory.Builder()
                        if hasInventory {
                            try subBuilder.mergeFrom(other: inventory)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        inventory = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Pb.InventoryItemRequest.Builder = Pb.InventoryItemRequest.Builder()
                        if hasInventoryRequest {
                            try subBuilder.mergeFrom(other: inventoryRequest)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        inventoryRequest = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:Pb.InventoryItemResponse.Builder = Pb.InventoryItemResponse.Builder()
                        if hasInventoryResponse {
                            try subBuilder.mergeFrom(other: inventoryResponse)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        inventoryResponse = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pb.Message.Builder {
                let resultDecodedBuilder = Pb.Message.Builder()
                if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = Int64(jsonValueVersion)!
                } else if let jsonValueVersion = jsonMap["version"] as? Int {
                    resultDecodedBuilder.version = Int64(jsonValueVersion)
                }
                if let jsonValueInventory = jsonMap["inventory"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.inventory = try Pb.Inventory.Builder.decodeToBuilder(jsonMap:jsonValueInventory).build()

                }
                if let jsonValueInventoryRequest = jsonMap["inventoryRequest"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.inventoryRequest = try Pb.InventoryItemRequest.Builder.decodeToBuilder(jsonMap:jsonValueInventoryRequest).build()

                }
                if let jsonValueInventoryResponse = jsonMap["inventoryResponse"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.inventoryResponse = try Pb.InventoryItemResponse.Builder.decodeToBuilder(jsonMap:jsonValueInventoryResponse).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Pb.Message.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Pb.Message.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Pb.Inventory: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pb.Inventory> {
        var mergedArray = Array<Pb.Inventory>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pb.Inventory? {
        return try Pb.Inventory.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(data: data, extensionRegistry:Pb.ProtocolRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hash": return self.hash
        default: return nil
        }
    }
}
extension Pb.Inventory.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Pb.Inventory
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hash": return self.hash
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hash":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.hash = newSubscriptValue
            default: return
            }
        }
    }
}
extension Pb.InventoryItemRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pb.InventoryItemRequest> {
        var mergedArray = Array<Pb.InventoryItemRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pb.InventoryItemRequest? {
        return try Pb.InventoryItemRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Pb.InventoryItemRequest {
        return try Pb.InventoryItemRequest.Builder().mergeFrom(data: data, extensionRegistry:Pb.ProtocolRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemRequest {
        return try Pb.InventoryItemRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Pb.InventoryItemRequest {
        return try Pb.InventoryItemRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemRequest {
        return try Pb.InventoryItemRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pb.InventoryItemRequest {
        return try Pb.InventoryItemRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemRequest {
        return try Pb.InventoryItemRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hash": return self.hash
        default: return nil
        }
    }
}
extension Pb.InventoryItemRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Pb.InventoryItemRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hash": return self.hash
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hash":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.hash = newSubscriptValue
            default: return
            }
        }
    }
}
extension Pb.InventoryItemResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pb.InventoryItemResponse> {
        var mergedArray = Array<Pb.InventoryItemResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pb.InventoryItemResponse? {
        return try Pb.InventoryItemResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Pb.InventoryItemResponse {
        return try Pb.InventoryItemResponse.Builder().mergeFrom(data: data, extensionRegistry:Pb.ProtocolRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemResponse {
        return try Pb.InventoryItemResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Pb.InventoryItemResponse {
        return try Pb.InventoryItemResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemResponse {
        return try Pb.InventoryItemResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pb.InventoryItemResponse {
        return try Pb.InventoryItemResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItemResponse {
        return try Pb.InventoryItemResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "from": return self.from
        case "data": return self.data
        default: return nil
        }
    }
}
extension Pb.InventoryItemResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Pb.InventoryItemResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "from": return self.from
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Pb.Message: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pb.Message> {
        var mergedArray = Array<Pb.Message>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pb.Message? {
        return try Pb.Message.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(data: data, extensionRegistry:Pb.ProtocolRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "inventory": return self.inventory
        case "inventoryRequest": return self.inventoryRequest
        case "inventoryResponse": return self.inventoryResponse
        default: return nil
        }
    }
}
extension Pb.Message.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Pb.Message
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "inventory": return self.inventory
            case "inventoryRequest": return self.inventoryRequest
            case "inventoryResponse": return self.inventoryResponse
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.version = newSubscriptValue
            case "inventory":
                guard let newSubscriptValue = newSubscriptValue as? Pb.Inventory else {
                    return
                }
                self.inventory = newSubscriptValue
            case "inventoryRequest":
                guard let newSubscriptValue = newSubscriptValue as? Pb.InventoryItemRequest else {
                    return
                }
                self.inventoryRequest = newSubscriptValue
            case "inventoryResponse":
                guard let newSubscriptValue = newSubscriptValue as? Pb.InventoryItemResponse else {
                    return
                }
                self.inventoryResponse = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
