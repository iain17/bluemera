/// Generated by the Protocol Buffers 3.4.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "Protocol.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Pb { }

public extension Pb {
    public struct ProtocolRoot {
        public static let `default` = ProtocolRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class InventoryItem : GeneratedMessage {
        public typealias BuilderType = Pb.InventoryItem.Builder

        public static func == (lhs: Pb.InventoryItem, rhs: Pb.InventoryItem) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var from:String! = nil
        public fileprivate(set) var hasFrom:Bool = false

        public fileprivate(set) var data:String! = nil
        public fileprivate(set) var hasData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFrom {
                try codedOutputStream.writeString(fieldNumber: 1, value:from)
            }
            if hasData {
                try codedOutputStream.writeString(fieldNumber: 2, value:data)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFrom {
                serialize_size += from.computeStringSize(fieldNumber: 1)
            }
            if hasData {
                serialize_size += data.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Pb.InventoryItem.Builder {
            return Pb.InventoryItem.classBuilder() as! Pb.InventoryItem.Builder
        }
        public func getBuilder() -> Pb.InventoryItem.Builder {
            return classBuilder() as! Pb.InventoryItem.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.InventoryItem.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.InventoryItem.Builder()
        }
        public func toBuilder() throws -> Pb.InventoryItem.Builder {
            return try Pb.InventoryItem.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pb.InventoryItem) throws -> Pb.InventoryItem.Builder {
            return try Pb.InventoryItem.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFrom {
                jsonMap["from"] = from
            }
            if hasData {
                jsonMap["data"] = data
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pb.InventoryItem {
            return try Pb.InventoryItem.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pb.InventoryItem {
            return try Pb.InventoryItem.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFrom {
                output += "\(indent) from: \(from) \n"
            }
            if hasData {
                output += "\(indent) data: \(data) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFrom {
                    hashCode = (hashCode &* 31) &+ from.hashValue
                }
                if hasData {
                    hashCode = (hashCode &* 31) &+ data.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pb.InventoryItem"
        }
        override public func className() -> String {
            return "Pb.InventoryItem"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Pb.InventoryItem = Pb.InventoryItem()
            public func getMessage() -> Pb.InventoryItem {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var from:String {
                get {
                    return builderResult.from
                }
                set (value) {
                    builderResult.hasFrom = true
                    builderResult.from = value
                }
            }
            public var hasFrom:Bool {
                get {
                    return builderResult.hasFrom
                }
            }
            @discardableResult
            public func setFrom(_ value:String) -> Pb.InventoryItem.Builder {
                self.from = value
                return self
            }
            @discardableResult
            public func clearFrom() -> Pb.InventoryItem.Builder{
                builderResult.hasFrom = false
                builderResult.from = nil
                return self
            }
            public var data:String {
                get {
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            @discardableResult
            public func setData(_ value:String) -> Pb.InventoryItem.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func clearData() -> Pb.InventoryItem.Builder{
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Pb.InventoryItem.Builder {
                builderResult = Pb.InventoryItem()
                return self
            }
            override public func clone() throws -> Pb.InventoryItem.Builder {
                return try Pb.InventoryItem.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Pb.InventoryItem {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Pb.InventoryItem {
                let returnMe:Pb.InventoryItem = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Pb.InventoryItem) throws -> Pb.InventoryItem.Builder {
                if other == Pb.InventoryItem() {
                    return self
                }
                if other.hasFrom {
                    from = other.from
                }
                if other.hasData {
                    data = other.data
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pb.InventoryItem.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItem.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        from = try codedInputStream.readString()

                    case 18:
                        data = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pb.InventoryItem.Builder {
                let resultDecodedBuilder = Pb.InventoryItem.Builder()
                if let jsonValueFrom = jsonMap["from"] as? String {
                    resultDecodedBuilder.from = jsonValueFrom
                }
                if let jsonValueData = jsonMap["data"] as? String {
                    resultDecodedBuilder.data = jsonValueData
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Pb.InventoryItem.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Pb.InventoryItem.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Inventory : GeneratedMessage {
        public typealias BuilderType = Pb.Inventory.Builder

        public static func == (lhs: Pb.Inventory, rhs: Pb.Inventory) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hash == rhs.hash)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var hash:Array<String> = Array<String>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !hash.isEmpty {
                for oneValuehash in hash {
                    try codedOutputStream.writeString(fieldNumber: 1, value:oneValuehash)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeHash:Int32 = 0
            for oneValuehash in hash {
                dataSizeHash += oneValuehash.computeStringSizeNoTag()
            }
            serialize_size += dataSizeHash
            serialize_size += 1 * Int32(hash.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Pb.Inventory.Builder {
            return Pb.Inventory.classBuilder() as! Pb.Inventory.Builder
        }
        public func getBuilder() -> Pb.Inventory.Builder {
            return classBuilder() as! Pb.Inventory.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Inventory.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Inventory.Builder()
        }
        public func toBuilder() throws -> Pb.Inventory.Builder {
            return try Pb.Inventory.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pb.Inventory) throws -> Pb.Inventory.Builder {
            return try Pb.Inventory.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !hash.isEmpty {
                var jsonArrayHash:Array<String> = []
                for oneValueHash in hash {
                    jsonArrayHash.append(oneValueHash)
                }
                jsonMap["hash"] = jsonArrayHash
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pb.Inventory {
            return try Pb.Inventory.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pb.Inventory {
            return try Pb.Inventory.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var hashElementIndex:Int = 0
            for oneValueHash in hash  {
                output += "\(indent) hash[\(hashElementIndex)]: \(oneValueHash)\n"
                hashElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueHash in hash {
                    hashCode = (hashCode &* 31) &+ oneValueHash.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pb.Inventory"
        }
        override public func className() -> String {
            return "Pb.Inventory"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Pb.Inventory = Pb.Inventory()
            public func getMessage() -> Pb.Inventory {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var hash:Array<String> {
                get {
                    return builderResult.hash
                }
                set (array) {
                    builderResult.hash = array
                }
            }
            @discardableResult
            public func setHash(_ value:Array<String>) -> Pb.Inventory.Builder {
                self.hash = value
                return self
            }
            @discardableResult
            public func clearHash() -> Pb.Inventory.Builder {
                builderResult.hash.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Pb.Inventory.Builder {
                builderResult = Pb.Inventory()
                return self
            }
            override public func clone() throws -> Pb.Inventory.Builder {
                return try Pb.Inventory.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Pb.Inventory {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Pb.Inventory {
                let returnMe:Pb.Inventory = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Pb.Inventory) throws -> Pb.Inventory.Builder {
                if other == Pb.Inventory() {
                    return self
                }
                if !other.hash.isEmpty {
                    builderResult.hash += other.hash
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pb.Inventory.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        hash += [try codedInputStream.readString()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pb.Inventory.Builder {
                let resultDecodedBuilder = Pb.Inventory.Builder()
                if let jsonValueHash = jsonMap["hash"] as? Array<String> {
                    var jsonArrayHash:Array<String> = []
                    for oneValueHash in jsonValueHash {
                        jsonArrayHash.append(oneValueHash)
                    }
                    resultDecodedBuilder.hash = jsonArrayHash
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Pb.Inventory.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Pb.Inventory.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class Message : GeneratedMessage {
        public typealias BuilderType = Pb.Message.Builder

        public static func == (lhs: Pb.Message, rhs: Pb.Message) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = fieldCheck && (lhs.hasInventoryItem == rhs.hasInventoryItem) && (!lhs.hasInventoryItem || lhs.inventoryItem == rhs.inventoryItem)
            fieldCheck = fieldCheck && (lhs.hasInventory == rhs.hasInventory) && (!lhs.hasInventory || lhs.inventory == rhs.inventory)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //OneOf declaration start

        public enum Msg {
            case OneOfMsgNotSet

            public func checkOneOfIsSet() -> Bool {
                switch self {
                case .OneOfMsgNotSet: return false
                default: return true
                }
            }
            case InventoryItem(Pb.InventoryItem)

            public static func getInventoryItem(_ value:Msg) -> Pb.InventoryItem? {
                switch value {
                case .InventoryItem(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
            case Inventory(Pb.Inventory)

            public static func getInventory(_ value:Msg) -> Pb.Inventory? {
                switch value {
                case .Inventory(let enumValue):
                    return enumValue
                    default: return nil
                }
            }
        }
        //OneOf declaration end

        fileprivate var storageMsg:Message.Msg =  Message.Msg.OneOfMsgNotSet
        public func getOneOfMsg() ->  Message.Msg {
            let copyObjectMsg = storageMsg
            return copyObjectMsg
        }
        public fileprivate(set) var version:Int64! = nil
        public fileprivate(set) var hasVersion:Bool = false

        public fileprivate(set) var inventoryItem:Pb.InventoryItem!{
            get {
                return Message.Msg.getInventoryItem(storageMsg)
            }
            set (newvalue) {
                storageMsg = Message.Msg.InventoryItem(newvalue)
            }
        }
        public fileprivate(set) var hasInventoryItem:Bool {
            get {
                guard let _ = Message.Msg.getInventoryItem(storageMsg) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        public fileprivate(set) var inventory:Pb.Inventory!{
            get {
                return Message.Msg.getInventory(storageMsg)
            }
            set (newvalue) {
                storageMsg = Message.Msg.Inventory(newvalue)
            }
        }
        public fileprivate(set) var hasInventory:Bool {
            get {
                guard let _ = Message.Msg.getInventory(storageMsg) else {
                    return false
                }
                return true
            }
            set(newValue) {
            }
        }
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasVersion {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:version)
            }
            if hasInventoryItem {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:inventoryItem)
            }
            if hasInventory {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:inventory)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasVersion {
                serialize_size += version.computeInt64Size(fieldNumber: 1)
            }
            if hasInventoryItem {
                if let varSizeinventoryItem = inventoryItem?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeinventoryItem
                }
            }
            if hasInventory {
                if let varSizeinventory = inventory?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizeinventory
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Pb.Message.Builder {
            return Pb.Message.classBuilder() as! Pb.Message.Builder
        }
        public func getBuilder() -> Pb.Message.Builder {
            return classBuilder() as! Pb.Message.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Message.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Pb.Message.Builder()
        }
        public func toBuilder() throws -> Pb.Message.Builder {
            return try Pb.Message.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pb.Message) throws -> Pb.Message.Builder {
            return try Pb.Message.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasVersion {
                jsonMap["version"] = "\(version)"
            }
            if hasInventoryItem {
                jsonMap["inventoryItem"] = try inventoryItem.encode()
            }
            if hasInventory {
                jsonMap["inventory"] = try inventory.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pb.Message {
            return try Pb.Message.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pb.Message {
            return try Pb.Message.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            if hasInventoryItem {
                output += "\(indent) inventoryItem {\n"
                if let outDescInventoryItem = inventoryItem {
                    output += try outDescInventoryItem.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasInventory {
                output += "\(indent) inventory {\n"
                if let outDescInventory = inventory {
                    output += try outDescInventory.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasInventoryItem {
                    if let hashValueinventoryItem = inventoryItem?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinventoryItem
                    }
                }
                if hasInventory {
                    if let hashValueinventory = inventory?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueinventory
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pb.Message"
        }
        override public func className() -> String {
            return "Pb.Message"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Pb.Message = Pb.Message()
            public func getMessage() -> Pb.Message {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var version:Int64 {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:Int64) -> Pb.Message.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Pb.Message.Builder{
                builderResult.hasVersion = false
                builderResult.version = nil
                return self
            }
            public var inventoryItem:Pb.InventoryItem! {
                get {
                    if inventoryItemBuilder_ != nil {
                        builderResult.inventoryItem = inventoryItemBuilder_.getMessage()
                    }
                    return builderResult.inventoryItem
                }
                set (value) {
                    builderResult.hasInventoryItem = true
                    builderResult.inventoryItem = value
                }
            }
            public var hasInventoryItem:Bool {
                get {
                    return builderResult.hasInventoryItem
                }
            }
            fileprivate var inventoryItemBuilder_:Pb.InventoryItem.Builder! {
                didSet {
                    builderResult.hasInventoryItem = true
                }
            }
            public func getInventoryItemBuilder() -> Pb.InventoryItem.Builder {
                if inventoryItemBuilder_ == nil {
                    inventoryItemBuilder_ = Pb.InventoryItem.Builder()
                    builderResult.inventoryItem = inventoryItemBuilder_.getMessage()
                    if inventoryItem != nil {
                        try! inventoryItemBuilder_.mergeFrom(other: inventoryItem)
                    }
                }
                return inventoryItemBuilder_
            }
            @discardableResult
            public func setInventoryItem(_ value:Pb.InventoryItem!) -> Pb.Message.Builder {
                self.inventoryItem = value
                return self
            }
            @discardableResult
            public func mergeInventoryItem(value:Pb.InventoryItem) throws -> Pb.Message.Builder {
                if builderResult.hasInventoryItem {
                    builderResult.inventoryItem = try Pb.InventoryItem.builderWithPrototype(prototype:builderResult.inventoryItem).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.inventoryItem = value
                }
                builderResult.hasInventoryItem = true
                return self
            }
            @discardableResult
            public func clearInventoryItem() -> Pb.Message.Builder {
                inventoryItemBuilder_ = nil
                builderResult.hasInventoryItem = false
                builderResult.inventoryItem = nil
                return self
            }
            public var inventory:Pb.Inventory! {
                get {
                    if inventoryBuilder_ != nil {
                        builderResult.inventory = inventoryBuilder_.getMessage()
                    }
                    return builderResult.inventory
                }
                set (value) {
                    builderResult.hasInventory = true
                    builderResult.inventory = value
                }
            }
            public var hasInventory:Bool {
                get {
                    return builderResult.hasInventory
                }
            }
            fileprivate var inventoryBuilder_:Pb.Inventory.Builder! {
                didSet {
                    builderResult.hasInventory = true
                }
            }
            public func getInventoryBuilder() -> Pb.Inventory.Builder {
                if inventoryBuilder_ == nil {
                    inventoryBuilder_ = Pb.Inventory.Builder()
                    builderResult.inventory = inventoryBuilder_.getMessage()
                    if inventory != nil {
                        try! inventoryBuilder_.mergeFrom(other: inventory)
                    }
                }
                return inventoryBuilder_
            }
            @discardableResult
            public func setInventory(_ value:Pb.Inventory!) -> Pb.Message.Builder {
                self.inventory = value
                return self
            }
            @discardableResult
            public func mergeInventory(value:Pb.Inventory) throws -> Pb.Message.Builder {
                if builderResult.hasInventory {
                    builderResult.inventory = try Pb.Inventory.builderWithPrototype(prototype:builderResult.inventory).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.inventory = value
                }
                builderResult.hasInventory = true
                return self
            }
            @discardableResult
            public func clearInventory() -> Pb.Message.Builder {
                inventoryBuilder_ = nil
                builderResult.hasInventory = false
                builderResult.inventory = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Pb.Message.Builder {
                builderResult = Pb.Message()
                return self
            }
            override public func clone() throws -> Pb.Message.Builder {
                return try Pb.Message.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Pb.Message {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Pb.Message {
                let returnMe:Pb.Message = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Pb.Message) throws -> Pb.Message.Builder {
                if other == Pb.Message() {
                    return self
                }
                if other.hasVersion {
                    version = other.version
                }
                if (other.hasInventoryItem) {
                    try mergeInventoryItem(value: other.inventoryItem)
                }
                if (other.hasInventory) {
                    try mergeInventory(value: other.inventory)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pb.Message.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Message.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        version = try codedInputStream.readInt64()

                    case 18:
                        let subBuilder:Pb.InventoryItem.Builder = Pb.InventoryItem.Builder()
                        if hasInventoryItem {
                            try subBuilder.mergeFrom(other: inventoryItem)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        inventoryItem = subBuilder.buildPartial()

                    case 26:
                        let subBuilder:Pb.Inventory.Builder = Pb.Inventory.Builder()
                        if hasInventory {
                            try subBuilder.mergeFrom(other: inventory)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        inventory = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pb.Message.Builder {
                let resultDecodedBuilder = Pb.Message.Builder()
                if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = Int64(jsonValueVersion)!
                } else if let jsonValueVersion = jsonMap["version"] as? Int {
                    resultDecodedBuilder.version = Int64(jsonValueVersion)
                }
                if let jsonValueInventoryItem = jsonMap["inventoryItem"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.inventoryItem = try Pb.InventoryItem.Builder.decodeToBuilder(jsonMap:jsonValueInventoryItem).build()

                }
                if let jsonValueInventory = jsonMap["inventory"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.inventory = try Pb.Inventory.Builder.decodeToBuilder(jsonMap:jsonValueInventory).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Pb.Message.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Pb.Message.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Pb.InventoryItem: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pb.InventoryItem> {
        var mergedArray = Array<Pb.InventoryItem>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pb.InventoryItem? {
        return try Pb.InventoryItem.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Pb.InventoryItem {
        return try Pb.InventoryItem.Builder().mergeFrom(data: data, extensionRegistry:Pb.ProtocolRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItem {
        return try Pb.InventoryItem.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Pb.InventoryItem {
        return try Pb.InventoryItem.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItem {
        return try Pb.InventoryItem.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pb.InventoryItem {
        return try Pb.InventoryItem.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.InventoryItem {
        return try Pb.InventoryItem.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "from": return self.from
        case "data": return self.data
        default: return nil
        }
    }
}
extension Pb.InventoryItem.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Pb.InventoryItem
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "from": return self.from
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Pb.Inventory: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pb.Inventory> {
        var mergedArray = Array<Pb.Inventory>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pb.Inventory? {
        return try Pb.Inventory.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(data: data, extensionRegistry:Pb.ProtocolRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Inventory {
        return try Pb.Inventory.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "hash": return self.hash
        default: return nil
        }
    }
}
extension Pb.Inventory.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Pb.Inventory
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "hash": return self.hash
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "hash":
                guard let newSubscriptValue = newSubscriptValue as? Array<String> else {
                    return
                }
                self.hash = newSubscriptValue
            default: return
            }
        }
    }
}
extension Pb.Message: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pb.Message> {
        var mergedArray = Array<Pb.Message>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pb.Message? {
        return try Pb.Message.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(data: data, extensionRegistry:Pb.ProtocolRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pb.Message {
        return try Pb.Message.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "inventoryItem": return self.inventoryItem
        case "inventory": return self.inventory
        default: return nil
        }
    }
}
extension Pb.Message.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Pb.Message
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "inventoryItem": return self.inventoryItem
            case "inventory": return self.inventory
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.version = newSubscriptValue
            case "inventoryItem":
                guard let newSubscriptValue = newSubscriptValue as? Pb.InventoryItem else {
                    return
                }
                self.inventoryItem = newSubscriptValue
            case "inventory":
                guard let newSubscriptValue = newSubscriptValue as? Pb.Inventory else {
                    return
                }
                self.inventory = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
